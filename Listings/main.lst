C51 COMPILER V9.56.0.0   MAIN                                                              09/28/2016 00:59:04 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(0,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) TABS(3) OBJECT(.\Objects\main.obj)

line level    source

   1          /********** 4_5B_Homework.C ****************************
   2          *動作：每按一次按鍵，令LED有六種變化
   3          *硬體：SW1-3(P0LED)ON, 按KEY1 
   4          ***********************************************/
   5          #include "MPC82.H"   //暫存器及組態定義
   6          
   7          #define fSYS   2211840
   8          uint16 code Pitch_TAB[] = {                              //Pitch Control Table
   9                   fSYS/(523*2*4),fSYS/(587*2*4),fSYS/(659*2*4),
  10                   fSYS/(698*2*4),fSYS/(785*2*4),fSYS/(880*2*4),
  11                   fSYS/(998*2*4),fSYS/(523*4*4)};
  12          
  13          const uint8 littleBee[] = {
  14             5,3,3,0,4,2,2,0,
  15             1,2,3,4,5,5,5,0,
  16             5,3,3,0,4,2,2,0,
  17             1,3,5,5,3,0,0,0,
  18             2,2,2,2,2,3,4,0,
  19             3,3,3,3,3,4,5,0,
  20             5,3,3,0,4,2,2,0,
  21             1,3,5,5,1,0,0,0
  22          };
  23          
  24          uint8 code greenMan[8][8]= //設定八個八單位矩陣
  25          {
  26          {0x00,0x8b,0xef,0x3c,0x18,0xa0,0xc0,0x00}, //第一張動作 走路中
  27          {0x00,0xdb,0x6f,0x3c,0x18,0x28,0xd0,0x00}, //第二張動作 走路中
  28          {0x10,0x4b,0x5f,0x3c,0x28,0x48,0xd0,0x00}, //第三張動作 走路中
  29          {0x53,0x4f,0x3c,0x18,0x28,0x48,0x90,0x00}, //第四張動作 走路中
  30          {0x93,0x8f,0xfc,0x38,0x28,0x50,0xe0,0x00}, //第五張動作 走路中
  31          {0x93,0xcf,0x3c,0x38,0x48,0xd0,0x20,0x00}, //第六張動作 走路中
  32          {0x03,0x5f,0xbc,0x78,0xc8,0x30,0x00,0x00}, //第七張動作 走路中
  33          {0x00,0x03,0x0f,0x7c,0x58,0xe0,0x00,0x00} //第八張動作 走路中
  34          };
  35          
  36          char flag = 0;    //設定變數 
  37          uint8 dsState = 0;
  38          uint8 inxlittleBee = 0;
  39          
  40          uint8 revers( uint8 org ){
  41   1         return ((org & 0x01) << 7 ) | ((org & 0x02) << 5) | ((org & 0x04) << 3) | ((org & 0x08) << 1)
  42   1             | ((org & 0x10) >> 1) | ((org & 0x20) >> 3) | ((org & 0x40) >> 5) | ((org & 0x80) >> 7);
  43   1      }
  44          
  45          uint8 getRotateImage(uint8 i, uint8 j){
  46   1         return ((greenMan[i][0] >> j) & 0x01)
  47   1               | ((greenMan[i][1] >> j) & 0x01) << 1
  48   1               | ((greenMan[i][2] >> j) & 0x01) << 2
  49   1               | ((greenMan[i][3] >> j) & 0x01) << 3
  50   1               | ((greenMan[i][4] >> j) & 0x01) << 4
  51   1               | ((greenMan[i][5] >> j) & 0x01) << 5
  52   1               | ((greenMan[i][6] >> j) & 0x01) << 6
  53   1               | ((greenMan[i][7] >> j) & 0x01) << 7;
  54   1      }
C51 COMPILER V9.56.0.0   MAIN                                                              09/28/2016 00:59:04 PAGE 2   

  55          
  56          void dotShow(){
  57   1         uint8 t = 10;  
  58   1         uint8 i, j, k;
  59   1         
  60   1         switch (dsState)
  61   1         {
  62   2            case 0:
  63   2               //X = 7>0 , Y = 0
  64   2               Scan = 0xFE;
  65   2               Data = 0xFE;
  66   2               do{
  67   3                  Scan = RL8( Scan );
  68   3                  Delay_ms( t  ); 
  69   3               }while( Scan != 0x7F );          
  70   2               break;
  71   2            
  72   2            case 1:
  73   2               //X = 0, Y = 0>7
  74   2               Scan = 0x7F;
  75   2               Data = 0xFE;
  76   2               do{
  77   3                  Data = RL8( Data );
  78   3                  Delay_ms( t  );
  79   3               }while( Data != 0x7F );       
  80   2               break;
  81   2      
  82   2            case 2:
  83   2               //X = 0>7, Y = 7
  84   2               Scan = 0x7F;
  85   2               Data = 0x7F;
  86   2               do{
  87   3                  Scan = RR8( Scan );
  88   3                  Delay_ms( t  ); 
  89   3               }while( Scan != 0xFE );          
  90   2               break;
  91   2      
  92   2            case 3:
  93   2               // X = 7, Y = 7>0
  94   2               Scan = 0xFE;
  95   2               Data = 0x7F;
  96   2               do{
  97   3                  Data = RR8( Data );
  98   3                  Delay_ms( t  ); 
  99   3               }while( Data != 0xFE );             
 100   2               break;
 101   2      
 102   2            case 4:
 103   2               //X = 7>0, Y = 0>7
 104   2               Scan = 0xFE;
 105   2               Data = 0xFE;
 106   2               do{
 107   3                  Data = RL8( Data );
 108   3                  Scan = RL8( Scan );
 109   3                  Delay_ms( t  ); 
 110   3               }while( Data != 0x7F );       
 111   2               break;
 112   2      
 113   2            case 5:
 114   2               //X = 0>7, Y = 7
 115   2               Scan = 0x7F;
 116   2               Data = 0x7F;
C51 COMPILER V9.56.0.0   MAIN                                                              09/28/2016 00:59:04 PAGE 3   

 117   2               do{
 118   3                  Scan = RR8( Scan );
 119   3                  Delay_ms( t  ); 
 120   3               }while( Scan != 0xFE );          
 121   2               break;
 122   2      
 123   2            case 6:
 124   2               //X = 7>0, Y = 7>0
 125   2               Scan = 0xFE;
 126   2               Data = 0x7F;
 127   2               do{
 128   3                  Data = RR8( Data );
 129   3                  Scan = RL8( Scan );
 130   3                  Delay_ms( t  ); 
 131   3               }while( Data != 0xFE );       
 132   2               break;
 133   2      
 134   2            case 7:
 135   2               //X = 0>7, Y = 0
 136   2               Scan = 0x7F;
 137   2               Data = 0xFE;
 138   2               do{
 139   3                  Scan = RR8( Scan );
 140   3                  Delay_ms( t  );
 141   3               }while( Scan != 0xFE );       
 142   2               break;
 143   2               
 144   2            case 8:
 145   2               //Green Go :Buttom
 146   2               Scan = 0xFE;
 147   2      
 148   2               for(t = 0 ; t < 4; t++){
 149   3                  for(j = 0 ; j < 8; j++){
 150   4                     for(k = 0 ; k < 10; k++){
 151   5                        for(i = 0 ; i < 8; i++){
 152   6                           Data = ~revers(greenMan[j][i]);
 153   6                           Delay_ms(1);
 154   6                           Data =  0xFF;
 155   6                           Scan=RL8(Scan); //換掃瞄下一行
 156   6                        }
 157   5                     }
 158   4                  }
 159   3               }
 160   2               break;
 161   2               
 162   2            case 9:
 163   2               //Green Go :Right
 164   2               Scan = 0x7F;
 165   2               for(t = 0 ; t < 4; t++){
 166   3                  for(j = 0 ; j < 8; j++){
 167   4                     for(k = 0 ; k < 10; k++){
 168   5                        for(i = 0 ; i < 8; i++){
 169   6                           Data = ~revers(getRotateImage(j, i));
 170   6                           Delay_ms(1);
 171   6                           Data =  0xFF;
 172   6                           Scan=RR8(Scan); //換掃瞄下一行
 173   6                        }
 174   5                     }
 175   4                  }
 176   3               }
 177   2               break;
 178   2            
C51 COMPILER V9.56.0.0   MAIN                                                              09/28/2016 00:59:04 PAGE 4   

 179   2            case 10:
 180   2               //Green Go :Top
 181   2               Scan = 0x7F;
 182   2      
 183   2               for(t = 0 ; t < 4; t++){
 184   3                  for(j = 0 ; j < 8; j++){
 185   4                     for(k = 0 ; k < 10; k++){
 186   5                        for(i = 0 ; i < 8; i++){
 187   6                           Data = ~greenMan[j][i];
 188   6                           Delay_ms(1);
 189   6                           Data =  0xFF;
 190   6                           Scan=RR8(Scan); //換掃瞄下一行
 191   6                        }
 192   5                     }
 193   4                  }
 194   3               }        
 195   2               break;
 196   2      
 197   2            case 11:
 198   2               //Green Go :Left
 199   2               Scan = 0xFE;
 200   2               for(t = 0 ; t < 4; t++){
 201   3                  for(j = 0 ; j < 8; j++){
 202   4                     for(k = 0 ; k < 10; k++){
 203   5                        for(i = 0 ; i < 8; i++){
 204   6                           Data = ~getRotateImage(j, i);
 205   6                           Delay_ms(1);
 206   6                           Data =  0xFF;
 207   6                           Scan=RL8(Scan); //換掃瞄下一行
 208   6                        }
 209   5                     }
 210   4                  }
 211   3               }
 212   2               break;
 213   2         }
 214   1         
 215   1         dsState = dsState == 11 ?  0 : dsState + 1;
 216   1      }
 217          
 218          
 219          void play(){
 220   1         
 221   1         uint16 dly;
 222   1         uint32 count;
 223   1         
 224   1         count = 0;
 225   1         while(1){
 226   2            
 227   2            if( littleBee[ inxlittleBee ] > 0){
 228   3            
 229   3                           dly =  Pitch_TAB[ littleBee[ inxlittleBee ] -1 ];
 230   3                           count += dly;
 231   3                           while( dly-- ); //改變延時
 232   3                           SPEAK = !SPEAK;   //SPEAK反相,令喇叭發出聲音
 233   3                           if(count > 300000) break;
 234   3            }else{
 235   3                           dly =  Pitch_TAB[ 0 ];
 236   3                           count += dly;
 237   3                           while( dly-- ); //改變延時
 238   3                           NOP();
 239   3                           if(count > 300000) break;
 240   3            }
C51 COMPILER V9.56.0.0   MAIN                                                              09/28/2016 00:59:04 PAGE 5   

 241   2         }
 242   1         inxlittleBee = inxlittleBee >= 63 ? 0 : inxlittleBee + 1;
 243   1      }
 244          
 245          
 246          main() 
 247          {
 248   1        P0M0=0; P0M1=0xFF; //設定P0為推挽式輸出(M0-1=01)
 249   1        while(1)       //重覆執行 
 250   1         {          //若flag=0，直接跳到此處
 251   2           if(KEY1==0)      //若有按鍵，flag反相
 252   2           {
 253   3              Delay_ms(1); //延時，防止機械彈跳    
 254   3              flag++; if(flag>5) flag=0;   
 255   3             while(KEY1==0); //若未放開鍵，空轉 
 256   3           }
 257   2      
 258   2         switch (flag)
 259   2            {
 260   3                  case 0:
 261   3                     LED--;
 262   3                     break;
 263   3                  
 264   3                  case 1:
 265   3                     LED++;
 266   3                     break;      
 267   3                  
 268   3                  case 2:
 269   3                     LED=0;
 270   3                     break;
 271   3                  
 272   3                  case 3:
 273   3                     LED=0xFF;
 274   3                     break;
 275   3                  
 276   3                  case 4:
 277   3                     dotShow();
 278   3                     break;
 279   3                  
 280   3                  case 5:
 281   3                     Scan = 0xFF;
 282   3                     play();
 283   3                     break;
 284   3                  
 285   3                  default:
 286   3                     break;
 287   3            }
 288   2               Delay_ms(100); //延時    
 289   2               
 290   2         }
 291   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1662    ----
   CONSTANT SIZE    =     80    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     84    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.

C51 COMPILER V9.56.0.0   MAIN                                                              09/28/2016 00:59:04 PAGE 6   


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
